<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cached Colorful Lines (2s Draw Time)</title>
    <style>
        body {
            margin: 0;
            background-color: black;
            overflow: hidden; /* Hide scrollbars */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh; /* Full viewport height */
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="animatedLineCanvas"></canvas>

    <script>
        // Get canvas and context
        const canvas = document.getElementById('animatedLineCanvas');
        const ctx = canvas.getContext('2d');

        // Animation parameters
        const segmentsPerCurve = 75; // Number of segments to approximate each Bezier curve
        const totalSegmentsPerLine = segmentsPerCurve * 2;
        const targetDrawTimeSeconds = 2.0; // Target time to draw one full line (changed from 0.1)
        const estimatedFramesPerSecond = 60;
        // Speed: segments to draw per frame to achieve targetDrawTimeSeconds
        const animationSpeed = totalSegmentsPerLine / (targetDrawTimeSeconds * estimatedFramesPerSecond); 
        const lineBorderWidth = 4; // Total width increase for the border (2px on each side)

        let allLines = []; // Array to store all line objects
        // Each line object: { controlPoints: [...], discretePoints: [...], isFullyDrawn: false, animationProgress: 0, cachedImage: null }

        // Canvas dimensions
        let w, h;

        /**
         * Generates a random number within a specified range.
         */
        function randomRange(min, max) {
            return Math.random() * (max - min) + min;
        }

        /**
         * Clamps a value between a minimum and maximum.
         */
        function clamp(value, min, max) {
            return Math.min(Math.max(value, min), max);
        }

        /**
         * Calculates a point on a cubic Bezier curve.
         */
        function bezierPoint(t, p0, p1, p2, p3) {
            const cX = 3 * (p1.x - p0.x);
            const bX = 3 * (p2.x - p1.x) - cX;
            const aX = p3.x - p0.x - cX - bX;
            const cY = 3 * (p1.y - p0.y);
            const bY = 3 * (p2.y - p1.y) - cY;
            const aY = p3.y - p0.y - cY - bY;
            const tSquared = t * t;
            const tCubed = tSquared * t;
            const resX = (aX * tCubed) + (bX * tSquared) + (cX * t) + p0.x;
            const resY = (aY * tCubed) + (bY * tSquared) + (cY * t) + p0.y;
            return { x: resX, y: resY };
        }

        /**
         * Generates randomized control points for a two-segment Bezier curve path from left to right.
         */
        function generateRandomizedPathControlPoints() {
            const p0 = { x: 0, y: randomRange(h * 0.2, h * 0.8) };
            const p6 = { x: w, y: randomRange(h * 0.2, h * 0.8) };
            const p3 = { x: randomRange(w * 0.4, w * 0.6), y: randomRange(h * 0.1, h * 0.9) };
            const p1 = {
                x: clamp(p0.x + randomRange(w * 0.1, w * 0.3), 0, w),
                y: clamp(p0.y + randomRange(-h * 0.3, h * 0.3), 0, h)
            };
            const p2 = {
                x: clamp(p3.x - randomRange(w * 0.1, w * 0.3), 0, w),
                y: clamp(p3.y + randomRange(-h * 0.3, h * 0.3), 0, h)
            };
            const smoothnessFactor = randomRange(0.8, 1.2);
            const p4 = {
                x: clamp(p3.x + (p3.x - p2.x) * smoothnessFactor, 0, w),
                y: clamp(p3.y + (p3.y - p2.y) * smoothnessFactor, 0, h)
            };
            const p5 = {
                x: clamp(p6.x - randomRange(w * 0.1, w * 0.3), 0, w),
                y: clamp(p6.y + randomRange(-h * 0.3, h * 0.3), 0, h)
            };
            return [p0, p1, p2, p3, p4, p5, p6];
        }

        /**
         * Calculates all discrete points along a Bezier path defined by control points.
         */
        function calculateDiscretePathPoints(controlPointsArray) {
            const discretePoints = [];
            if (controlPointsArray.length < 7) return discretePoints;
            const [p0, p1, p2, p3, p4, p5, p6] = controlPointsArray;
            discretePoints.push(p0);
            for (let i = 0; i < segmentsPerCurve; i++) {
                discretePoints.push(bezierPoint((i + 1) / segmentsPerCurve, p0, p1, p2, p3));
            }
            for (let i = 0; i < segmentsPerCurve; i++) {
                discretePoints.push(bezierPoint((i + 1) / segmentsPerCurve, p3, p4, p5, p6));
            }
            return discretePoints;
        }
        
        /**
         * Sets canvas dimensions based on window size.
         */
        function setCanvasSize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            w = canvas.width;
            h = canvas.height;
        }

        /**
         * Generates data for a new line and adds it to the list of lines.
         */
        function startNewLine() {
            const controlPoints = generateRandomizedPathControlPoints();
            const discretePoints = calculateDiscretePathPoints(controlPoints);
            if (discretePoints.length > 0) {
                 allLines.push({
                    controlPoints: controlPoints,
                    discretePoints: discretePoints,
                    isFullyDrawn: false,
                    animationProgress: 0,
                    cachedImage: null // Initialize cachedImage
                });
            } else {
                console.error("Failed to generate points for a new line.");
            }
        }

        /**
         * Renders a fully drawn line to an off-screen canvas and stores it.
         * @param {object} line - The line object to cache.
         */
        function cacheLine(line) {
            if (!line || !line.discretePoints || line.discretePoints.length === 0) return;

            const offScreenCanvas = document.createElement('canvas');
            offScreenCanvas.width = w; // Use current main canvas dimensions
            offScreenCanvas.height = h;
            const offScreenCtx = offScreenCanvas.getContext('2d');

            // Common line properties
            offScreenCtx.lineCap = 'round';
            offScreenCtx.lineJoin = 'round';
            const baseLineWidth = Math.max(6, Math.min(20, Math.min(w, h) * 0.02));

            // 1. Draw the black border
            offScreenCtx.strokeStyle = 'black';
            offScreenCtx.lineWidth = baseLineWidth + lineBorderWidth;
            offScreenCtx.beginPath();
            offScreenCtx.moveTo(line.discretePoints[0].x, line.discretePoints[0].y);
            for (let i = 1; i < line.discretePoints.length; i++) {
                offScreenCtx.lineTo(line.discretePoints[i].x, line.discretePoints[i].y);
            }
            offScreenCtx.stroke();

            // 2. Draw the colorful line on top
            const gradient = offScreenCtx.createLinearGradient(w * 0.05, h / 2, w * 0.95, h / 2);
            gradient.addColorStop(0.0, '#FFC400');    // Yellow-Orange
            gradient.addColorStop(0.25, '#FF9100');   // Orange
            gradient.addColorStop(0.5, '#FF1744');    // Deep Pink/Red
            gradient.addColorStop(0.75, '#AA00FF');   // Purple
            gradient.addColorStop(1.0, '#2979FF');    // Blue
            offScreenCtx.strokeStyle = gradient;
            offScreenCtx.lineWidth = baseLineWidth;
            
            offScreenCtx.beginPath();
            offScreenCtx.moveTo(line.discretePoints[0].x, line.discretePoints[0].y);
            for (let i = 1; i < line.discretePoints.length; i++) {
                offScreenCtx.lineTo(line.discretePoints[i].x, line.discretePoints[i].y);
            }
            offScreenCtx.stroke();

            line.cachedImage = offScreenCanvas; // Store the cached canvas
        }

        /**
         * Draws all lines on the main canvas.
         */
        function draw() {
            ctx.clearRect(0, 0, w, h); // Clear main canvas

            allLines.forEach(line => {
                if (line.isFullyDrawn && line.cachedImage) {
                    // Draw the pre-rendered cached image
                    ctx.drawImage(line.cachedImage, 0, 0);
                } else if (!line.isFullyDrawn && line.discretePoints && line.discretePoints.length > 0) {
                    // This is the actively animating line, draw it segment by segment
                    const segmentsToDraw = Math.floor(line.animationProgress);
                    
                    // Common line properties
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    const baseLineWidth = Math.max(6, Math.min(20, Math.min(w, h) * 0.02));

                    if (segmentsToDraw === 0 && line.animationProgress < 1 && line.animationProgress > 0) {
                        // If animation just started (progress > 0 but not enough for a full segment),
                        // we might still want to draw a tiny bit for the border to appear immediately.
                        // However, the current logic draws full segments, so this check might be more
                        // complex than needed if we only draw full segments.
                        // For now, this condition prevents drawing a single dot if no full segment is ready.
                    } else if (segmentsToDraw === 0 && line.animationProgress === 0) {
                        return; // Don't draw if animation hasn't even started for this line.
                    }


                    // 1. Draw the black border for the animating line
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = baseLineWidth + lineBorderWidth;
                    ctx.beginPath();
                    ctx.moveTo(line.discretePoints[0].x, line.discretePoints[0].y);
                    for (let i = 1; i <= segmentsToDraw && i < line.discretePoints.length; i++) {
                        ctx.lineTo(line.discretePoints[i].x, line.discretePoints[i].y);
                    }
                    ctx.stroke();

                    // 2. Draw the colorful line on top for the animating line
                    const gradient = ctx.createLinearGradient(w * 0.05, h / 2, w * 0.95, h / 2);
                    gradient.addColorStop(0.0, '#FFC400');
                    gradient.addColorStop(0.25, '#FF9100');
                    gradient.addColorStop(0.5, '#FF1744');
                    gradient.addColorStop(0.75, '#AA00FF');
                    gradient.addColorStop(1.0, '#2979FF');
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = baseLineWidth;
                    
                    ctx.beginPath();
                    ctx.moveTo(line.discretePoints[0].x, line.discretePoints[0].y);
                    for (let i = 1; i <= segmentsToDraw && i < line.discretePoints.length; i++) {
                        ctx.lineTo(line.discretePoints[i].x, line.discretePoints[i].y);
                    }
                    ctx.stroke();
                }
            });
        }

        /**
         * Animation loop.
         */
        function animate() {
            if (allLines.length > 0) {
                const currentLine = allLines[allLines.length - 1]; 

                if (!currentLine.isFullyDrawn) {
                    currentLine.animationProgress += animationSpeed;

                    if (currentLine.animationProgress >= totalSegmentsPerLine) {
                        currentLine.animationProgress = totalSegmentsPerLine; // Cap it
                        currentLine.isFullyDrawn = true;
                        cacheLine(currentLine); // Cache the line now that it's fully drawn
                        startNewLine(); // Start a new line
                    }
                }
            } else {
                startNewLine(); // Ensure there's always a line to animate if array is empty
            }

            draw();
            requestAnimationFrame(animate);
        }

        /**
         * Handles window resize events.
         */
        function handleResize() {
            setCanvasSize();
            allLines = []; // Clear all existing lines (and their caches)
            startNewLine(); 
            if (allLines.length > 0 && allLines[0].discretePoints.length > 0) {
                draw(); 
            }
        }

        /**
         * Initializes the animation.
         */
        function init() {
            setCanvasSize();
            startNewLine(); 
            if (allLines.length > 0 && allLines[0].discretePoints.length > 0) {
                animate();
            } else {
                console.error("Initialization failed: Could not start the first line.");
            }
        }

        // Event listeners
        window.addEventListener('resize', handleResize);

        // Start
        init();
    </script>
</body>
</html>
